<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <!-- <script src="1.js"></script> -->
  <!-- remark 1:
    å®ç° key in obj / for...in / deleteçš„å“åº”
    NaN!==NaN è®¾ç½®æ–°å€¼ä¸ºNaNæ—¶é¿å…ä¸å¿…è¦çš„æ›´æ–°
  -->
  <!-- <script>
    const obj = { foo: NaN, bar: 2 }

    const p1 = reactive(obj)

    effect(() => {
      for (const key in p1) {
        console.log(`key:${key}, value:${p1[key]}`)
      }
    })

    p1.foo = NaN
  </script> -->

  <!-- å®ç°ç»§æ‰¿åŸå‹å¯¹è±¡çš„æ•°æ®å“åº”ï¼Œé¿å…åŸå‹ä¸å¿…è¦çš„æ›´æ–° -->
  <!-- <script>
    const obj = { name: 'obj' }
    const proto = { name: 'proto', bar: 1 }
    const child = reactive(obj)
    child.name = 'child'
    const parent = reactive(proto)
    parent.name = 'parent'
    // ä½¿ç”¨ parent ä½œä¸º child çš„åŸå‹
    Object.setPrototypeOf(child, parent)

    effect(() => {
    console.log(child.bar)
    })

    child.bar = 2

    console.log(child[Symbol.for(RAW)] === obj)
    console.log(parent[Symbol.for(RAW)] === proto)
  </script> -->

  <!-- remark 2:
    å®ç°æµ…ä»£ç†å’Œæ·±ä»£ç†
  -->
  <!-- <script src="2.js"></script>
  <script>
    const obj = {
      foo: {
        bar: 1,
        bar2: {
          a: 1
        }
      },
      footer: 999
    }
    const p = reactive(obj)
    // const p2 = shallowReactive(obj)

    effect(() => {
      console.log(p.foo.bar2.a)
    })

    p.foo.bar2.a = 200
  </script> -->

  <!-- remark 3:
    å®ç°åªè¯»
  -->
  <!-- <script src="3.js"></script>
  <script>
    const obj = {
      foo: {
        bar: 1
      },
      footer: 999
    }

    const p = readonly(obj)
    const p2 = shallowReadonly(obj)
    p.foo = 2
    console.log('ğŸš€: ~ p:', p)
    p2.foo = 2
    delete p.foo
    delete p2.foo
    console.log('ğŸš€: ~ p2:', p2)
  </script> -->

  <!-- remark 4:
    ä»£ç†æ•°ç»„
    è§¦å‘lengthçš„å‰¯ä½œç”¨å‡½æ•°
    ownKeysé’©å­æ‹¦æˆªfor...inï¼Œå­˜å‚¨ITERATE_KEYä¾èµ–
  -->
  <!-- <script src="4.js"></script>
  <script>
    const arr = reactive([0, 1, 2, 3, 4, 5])
    effect(() => {
      for (const key in arr)
      console.log(`for...inï¼š${arr}`)
    })
    arr[100] = 100
  </script> -->

  <!-- remark 5:
    ä¼˜åŒ–
    for...of å¾ªç¯ä¼šè§¦å‘Symbol.iterator å±æ€§ï¼Œåˆ™éœ€è¦è¿‡æ»¤è¯¥key
  -->
  <!-- <script src="5.js"></script>
  <script>
    const arr = reactive([1, 2, 3, 4, 5])

    effect(() => {
      for (const key in arr)
      console.log(`for...inï¼š${key}`)
    })

    effect(() => {
      for (const value of arr) {
        console.log(`for...ofï¼š${value}`)
      }
    })

    arr[0] = 10
    arr.length = 0
  </script> -->

  <!-- remark 6:
    é‡å†™ Array.prototype['includes', 'indexOf', 'lastIndexOf']
  -->
  <!-- <script src="6.js"></script>
  <script>
    const obj = {}
    const arr = reactive([obj])

    console.log('includes origin', arr.includes(obj))
    console.log('includes proxy', arr.includes(arr[0]))

    console.log('indexOf origin', arr.indexOf(obj))
    console.log('indexOf proxy', arr.indexOf(arr[0]))

    console.log('lastIndexOf origin', arr.lastIndexOf(obj))
    console.log('lastIndexOf proxy', arr.lastIndexOf(arr[0]))
  </script> -->

  <!-- remark 7:
    é‡å†™ Array.prototype['push', 'pop', 'unshift', 'shift', 'splice']
  -->
  <!-- <script src="7.js"></script>
  <script>
    const arr = reactive([])

    effect(() => {
      arr.push(1)
      console.log('ğŸš€: ~ effect ~ arr:', arr)
    })

    effect(() => {
      arr.push(2)
      console.log('ğŸš€: ~ effect2 ~ arr:', arr)
    })
  </script> -->

  <!-- remark 8:
    Setä¸Proxyä¹‹é—´çš„å…³ç³»
  -->
  <!-- <script>
    const s = new Set([1, 2, 3])
    const p = new Proxy(s, {
      get (target, key, receiver) {
        if (key === 'size') {
          // å¦‚æœè¯»å–çš„æ˜¯ size å±æ€§ï¼Œ
          // æŒ‡å®š receiver ä¸ºåŸå§‹å¯¹è±¡ target
          // remarkï¼šå› ä¸ºä»£ç†å¯¹è±¡ä¸å­˜åœ¨å†…éƒ¨æ§½ [[SetData]]ã€‚ åŸå§‹å¯¹è±¡æ‰æœ‰
          return Reflect.get(target, key, target)
        }

        // return Reflect.get(target, key, receiver)
        
        // å°†æ–¹æ³•ä¸åŸå§‹æ•°æ®å¯¹è±¡ target ç»‘å®šåè¿”å›
        // remarkï¼šå°†åŸå§‹å¯¹è±¡çš„æ–¹æ³•è¿›è¡Œç»‘å®šï¼Œå¦‚delete() ç­‰æ–¹æ³•
        return target[key].bind(target)
      }
    })

    p.delete(1)
    console.log('ğŸš€: ~ p:', p.size)
  </script> -->

  <!-- remark 9:
    ä»£ç†Set/Map
    å®ç°forEach/for...ofçš„å“åº”å¼
  -->
  <script src="8.js"></script>
  <script>
    /* const p = reactive(new Set([1, 2, 3]))

    effect(() => {
      console.log('p', p.size)
    })

    p.add(1) */

    /* const p3 = reactive(new Map([['key', 1]]))

    effect(() => {
      console.log('p3', p3.get('key'))
    })

    p3.set('key', 2) */

    // æ±¡æŸ“åŸå§‹æ•°æ®
    // åŸå§‹æ•°æ® m
    /* const m = new Map()
    // p1 æ˜¯ m çš„ä»£ç†å¯¹è±¡
    const p1 = reactive(m)
    // p2 æ˜¯å¦ä¸€ä¸ªä»£ç†å¯¹è±¡
    const p2 = reactive(new Map())

    // ä¸º p1 è®¾ç½®ä¸€ä¸ªé”®å€¼å¯¹ï¼Œå€¼æ˜¯ä»£ç†å¯¹è±¡ p2
    p1.set('p2', p2)

    effect(() => {
      // æ³¨æ„ï¼Œè¿™é‡Œæˆ‘ä»¬é€šè¿‡åŸå§‹æ•°æ® m æ¥è®¿é—® p2
      console.log(m.get('p2').size)
    })

    // æ³¨æ„ï¼Œè¿™é‡Œæˆ‘ä»¬é€šè¿‡åŸå§‹æ•°æ® m ä¸º p2 è®¾ç½®ä¸€ä¸ªé”®å€¼å¯¹
    m.get('p2').set('foo', 1) */

    /* const p = reactive(new Map([
      [{key: 1}, { value: 1 }]
    ]))

    effect(() => {
      p.forEach((value, key, m) => {
        console.log(value) // { value: 1 }
        console.log(key) // { key: 1 }
      })
    })

    p.set({key: 2}, { value: 2 }) // èƒ½å¤Ÿè§¦å‘å“åº” */

    const p4 = reactive(new Map([
      ['key1', 'value1'],
      ['key2', 'value2']
    ]))

    effect(() => {
      for (const value of p4.keys()) {
        console.log(value)
      }
    })

    p4.set('key2', 'value3') // è¿™æ˜¯ä¸€ä¸ª SET çš„ç±»å‹ï¼Œå®ƒä¿®æ”¹äº† key2 çš„å€¼
  </script>
</body>

</html>